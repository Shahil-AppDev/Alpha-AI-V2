#!/usr/bin/env python3
"""
Exploit Module - LLM-powered payload generation and exploit template adaptation.
This module provides tools for generating reverse shell payloads and adapting exploit templates.
"""

import os
import re
import json
import logging
from typing import Dict, Any, Optional, List
from pathlib import Path

# Import LLM client for code generation
import requests
from dotenv import load_dotenv

# Load environment variables
load_dotenv()

# Configure logging
logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


class ExploitGenerator:
    """
    LLM-powered exploit generation and template adaptation.
    """
    
    def __init__(self, llm_endpoint: str = None, llm_api_key: str = None):
        """
        Initialize the exploit generator.
        
        Args:
            llm_endpoint: LLM API endpoint for code generation
            llm_api_key: API key for LLM service
        """
        self.llm_endpoint = llm_endpoint or os.getenv("LLM_ENDPOINT", "http://llm-service:8000/generate")
        self.llm_api_key = llm_api_key or os.getenv("LLM_API_KEY", "test-key")
        
        # Supported payload languages
        self.supported_languages = {
            "python": "Python reverse shell",
            "bash": "Bash reverse shell", 
            "powershell": "PowerShell reverse shell",
            "nc": "Netcat reverse shell",
            "perl": "Perl reverse shell",
            "ruby": "Ruby reverse shell"
        }
        
        logger.info("ExploitGenerator initialized with LLM support")
    
    def _call_llm(self, prompt: str) -> str:
        """
        Make a call to the LLM for code generation.
        
        Args:
            prompt: The prompt to send to the LLM
            
        Returns:
            Generated code from the LLM
        """
        try:
            payload = {
                "model": "gpt-3.5-turbo",
                "messages": [
                    {
                        "role": "system", 
                        "content": "You are an expert penetration tester and exploit developer. Generate clean, functional code for security testing purposes only. Always provide working code without syntax errors."
                    },
                    {
                        "role": "user",
                        "content": prompt
                    }
                ],
                "max_tokens": 1000,
                "temperature": 0.3
            }
            
            headers = {
                "Content-Type": "application/json",
                "Authorization": f"Bearer {self.llm_api_key}"
            }
            
            response = requests.post(
                self.llm_endpoint,
                json=payload,
                headers=headers,
                timeout=30
            )
            
            response.raise_for_status()
            result = response.json()
            
            return result.get("choices", [{}])[0].get("message", {}).get("content", "")
            
        except Exception as e:
            logger.error(f"Error calling LLM: {e}")
            raise Exception(f"Failed to generate code with LLM: {str(e)}")
    
    def generate_reverse_shell_payload(self, ip: str, port: int, language: str = "python") -> Dict[str, Any]:
        """
        Generate a reverse shell payload using LLM code generation.
        
        Args:
            ip: Target IP address for the reverse shell connection
            port: Target port for the reverse shell connection
            language: Programming language for the payload (python, bash, powershell, nc, perl, ruby)
            
        Returns:
            Dictionary containing the generated payload and metadata
        """
        try:
            # Validate inputs
            if not self._validate_ip(ip):
                return {
                    "success": False,
                    "error": f"Invalid IP address: {ip}"
                }
            
            if not self._validate_port(port):
                return {
                    "success": False,
                    "error": f"Invalid port number: {port}"
                }
            
            if language.lower() not in self.supported_languages:
                return {
                    "success": False,
                    "error": f"Unsupported language: {language}. Supported: {', '.join(self.supported_languages.keys())}"
                }
            
            # Create LLM prompt for reverse shell generation
            prompt = f"""
Generate a reverse shell payload in {language} that connects to {ip}:{port}.

Requirements:
1. The code should be clean and functional
2. Include proper error handling
3. Add comments explaining the key components
4. Make it suitable for penetration testing
5. Ensure it's a reverse shell (target connects back to attacker)
6. Include any necessary imports or dependencies

Language: {self.supported_languages[language.lower()]}
Target: {ip}:{port}

Please provide only the working code without explanations.
"""
            
            logger.info(f"Generating {language} reverse shell payload for {ip}:{port}")
            
            # Generate code using LLM
            generated_code = self._call_llm(prompt)
            
            # Clean and validate the generated code
            cleaned_code = self._clean_generated_code(generated_code)
            
            # Add security warning
            security_warning = "# WARNING: For authorized penetration testing only\n"
            final_code = security_warning + cleaned_code
            
            return {
                "success": True,
                "payload": final_code,
                "language": language.lower(),
                "target_ip": ip,
                "target_port": port,
                "payload_type": "reverse_shell",
                "length": len(final_code)
            }
            
        except Exception as e:
            logger.error(f"Error generating reverse shell payload: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def adapt_exploit_template(self, exploit_template_content: str, target_info: Dict[str, Any]) -> Dict[str, Any]:
        """
        Adapt an exploit template by filling in placeholders with target-specific information.
        
        Args:
            exploit_template_content: The exploit template content as a string
            target_info: Dictionary containing target information (ip, port, version, etc.)
            
        Returns:
            Dictionary containing the adapted exploit and metadata
        """
        try:
            # Validate template content
            if not exploit_template_content or not exploit_template_content.strip():
                return {
                    "success": False,
                    "error": "Empty exploit template content provided"
                }
            
            if not target_info or not isinstance(target_info, dict):
                return {
                    "success": False,
                    "error": "Invalid or empty target information provided"
                }
            
            logger.info("Adapting exploit template content")
            
            # Create LLM prompt for template adaptation
            target_info_str = json.dumps(target_info, indent=2)
            
            prompt = f"""
I need you to adapt an exploit template by filling in placeholders with specific target information.

Template content:
```
{exploit_template_content}
```

Target information:
{target_info_str}

Instructions:
1. Identify all placeholders in the template (like {{TARGET_IP}}, {{TARGET_PORT}}, {{VERSION}}, etc.)
2. Replace them with the appropriate values from the target information
3. Ensure the resulting code is syntactically correct
4. Add comments where significant changes were made
5. Preserve the original structure and logic of the template
6. If any required information is missing, add a comment indicating what needs to be filled

Please provide the complete adapted exploit code without explanations.
"""
            
            # Generate adapted code using LLM
            adapted_code = self._call_llm(prompt)
            
            # Clean the generated code
            cleaned_adapted_code = self._clean_generated_code(adapted_code)
            
            # Add adaptation metadata as comments
            metadata_comments = f"# Adapted from template content\n"
            metadata_comments += f"# Target: {target_info.get('ip', 'unknown')}:{target_info.get('port', 'unknown')}\n"
            metadata_comments += f"# Adaptation timestamp: {self._get_timestamp()}\n"
            
            final_adapted_code = metadata_comments + cleaned_adapted_code
            
            # Identify what placeholders were filled
            placeholders_filled = self._identify_placeholders_filled(exploit_template_content, target_info)
            
            return {
                "success": True,
                "adapted_exploit": final_adapted_code,
                "original_template_length": len(exploit_template_content),
                "target_info": target_info,
                "placeholders_filled": placeholders_filled,
                "length": len(final_adapted_code)
            }
            
        except Exception as e:
            logger.error(f"Error adapting exploit template: {e}")
            return {
                "success": False,
                "error": str(e)
            }
    
    def _validate_ip(self, ip: str) -> bool:
        """Validate IP address format."""
        import ipaddress
        try:
            ipaddress.ip_address(ip)
            return True
        except ValueError:
            return False
    
    def _validate_port(self, port: int) -> bool:
        """Validate port number."""
        return 1 <= port <= 65535
    
    def _clean_generated_code(self, code: str) -> str:
        """Clean and format the generated code."""
        # Remove markdown code blocks if present
        code = re.sub(r'```[\w]*\n?', '', code)
        code = re.sub(r'```', '', code)
        
        # Remove excessive whitespace while preserving structure
        lines = code.split('\n')
        cleaned_lines = []
        
        for line in lines:
            stripped = line.strip()
            if stripped:  # Keep non-empty lines
                cleaned_lines.append(stripped)
            elif cleaned_lines and cleaned_lines[-1] != '':  # Preserve single empty lines
                cleaned_lines.append('')
        
        return '\n'.join(cleaned_lines)
    
    def _identify_placeholders_filled(self, template: str, target_info: Dict[str, Any]) -> List[str]:
        """Identify which placeholders were likely filled in the template."""
        placeholders = []
        
        # Common placeholder patterns
        patterns = [
            r'\{\{([^}]+)\}\}',  # {{PLACEHOLDER}}
            r'\$\{([^}]+)\}',    # ${PLACEHOLDER}
            r'#([^#]+)#',         # #PLACEHOLDER#
            r'<<<([^>]+)>>>',     # <<<PLACEHOLDER>>>
        ]
        
        for pattern in patterns:
            matches = re.findall(pattern, template)
            for match in matches:
                placeholders.append(match.strip())
        
        # Check if target info keys match any placeholders
        filled_placeholders = []
        for placeholder in placeholders:
            placeholder_lower = placeholder.lower()
            for key in target_info.keys():
                if key.lower() in placeholder_lower or placeholder_lower in key.lower():
                    filled_placeholders.append(placeholder)
                    break
        
        return filled_placeholders
    
    def _get_timestamp(self) -> str:
        """Get current timestamp for metadata."""
        from datetime import datetime
        return datetime.now().isoformat()


# Global exploit generator instance
_exploit_generator = None


def get_exploit_generator() -> ExploitGenerator:
    """Get or create the global exploit generator instance."""
    global _exploit_generator
    if _exploit_generator is None:
        _exploit_generator = ExploitGenerator()
    return _exploit_generator


def generate_reverse_shell_payload(ip: str, port: int, language: str = "python") -> Dict[str, Any]:
    """
    Generate a reverse shell payload using LLM code generation.
    
    Args:
        ip: Target IP address for the reverse shell connection
        port: Target port for the reverse shell connection  
        language: Programming language for the payload (python, bash, powershell, nc, perl, ruby)
        
    Returns:
        Dictionary containing the generated payload and metadata
    """
    generator = get_exploit_generator()
    return generator.generate_reverse_shell_payload(ip, port, language)


def adapt_exploit_template(exploit_template_content: str, target_info: Dict[str, Any]) -> Dict[str, Any]:
    """
    Adapt an exploit template by filling in placeholders with target-specific information.
    
    Args:
        exploit_template_content: The exploit template content as a string
        target_info: Dictionary containing target information (ip, port, version, etc.)
        
    Returns:
        Dictionary containing the adapted exploit and metadata
    """
    generator = get_exploit_generator()
    return generator.adapt_exploit_template(exploit_template_content, target_info)


# Standalone test code
if __name__ == "__main__":
    print("=== Exploit Module Test ===")
    
    # Test reverse shell generation
    print("\n1. Testing reverse shell payload generation:")
    result = generate_reverse_shell_payload("192.168.1.100", 4444, "python")
    print(f"Success: {result['success']}")
    if result['success']:
        print(f"Language: {result['language']}")
        print(f"Target: {result['target_ip']}:{result['target_port']}")
        print(f"Payload length: {result['length']}")
        print("Generated payload:")
        print(result['payload'][:500] + "..." if len(result['payload']) > 500 else result['payload'])
    else:
        print(f"Error: {result['error']}")
    
    # Test exploit template adaptation
    print("\n2. Testing exploit template adaptation:")
    
    # Sample template content for testing
    sample_template = """#!/usr/bin/env python3
# Sample exploit template

TARGET_IP = "{{TARGET_IP}}"
TARGET_PORT = "{{TARGET_PORT}}"
TARGET_VERSION = "{{VERSION}}"

def exploit():
    print(f"Attacking {TARGET_IP}:{TARGET_PORT}")
    print(f"Target version: {TARGET_VERSION}")
    # Exploit logic here
    
if __name__ == "__main__":
    exploit()
"""
    
    target_info = {
        "ip": "192.168.1.100",
        "port": 8080,
        "version": "2.3.1",
        "service": "web_server"
    }
    
    result = adapt_exploit_template(sample_template, target_info)
    print(f"Success: {result['success']}")
    if result['success']:
        print(f"Original template length: {result['original_template_length']}")
        print(f"Placeholders filled: {result['placeholders_filled']}")
        print("Adapted exploit:")
        print(result['adapted_exploit'])
    else:
        print(f"Error: {result['error']}")
    
    print("\n=== Exploit Module Test Complete ===")


# ToolManager registration functions
def get_reverse_shell_tool_info():
    """Return tool information for reverse shell generation."""
    return {
        'name': 'generate_reverse_shell_payload',
        'description': 'Generate reverse shell payload using LLM assistance',
        'parameters': {
            'ip': {
                'type': 'string',
                'description': 'Target IP address for reverse shell connection',
                'required': True
            },
            'port': {
                'type': 'integer',
                'description': 'Target port for reverse shell connection (1-65535)',
                'required': True
            },
            'language': {
                'type': 'string',
                'description': 'Programming language for payload (python, bash, powershell, perl, ruby, nc)',
                'default': 'python',
                'required': False
            }
        },
        'return_value': {
            'type': 'dict',
            'description': 'Generated reverse shell payload with metadata'
        }
    }


def get_exploit_adaptation_tool_info():
    """Return tool information for exploit template adaptation."""
    return {
        'name': 'adapt_exploit_template',
        'description': 'Adapt exploit template by filling placeholders with target information',
        'parameters': {
            'exploit_template_content': {
                'type': 'string',
                'description': 'The exploit template content containing placeholders',
                'required': True
            },
            'target_info': {
                'type': 'dict',
                'description': 'Target information (IP, port, CVE details, etc.)',
                'required': True
            }
        },
        'return_value': {
            'type': 'dict',
            'description': 'Adapted exploit code with metadata'
        }
    }


def get_all_tool_info():
    """Return information for all tools in this module."""
    return {
        'tools': [
            get_reverse_shell_tool_info(),
            get_exploit_adaptation_tool_info()
        ]
    }
